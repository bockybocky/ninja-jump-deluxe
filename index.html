<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ü•∑ Ninja Jump Deluxe ‚Äî ÂøçËÄÖË∑≥Ë∫çË±™ËèØÁâà</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Outfit', sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #wrapper {
            position: relative;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(100, 100, 255, 0.3), 0 0 120px rgba(100, 100, 255, 0.1);
        }

        canvas {
            display: block;
            cursor: pointer;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #hud {
            position: absolute;
            top: 12px;
            left: 16px;
            right: 16px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: #fff;
            font-size: 15px;
            z-index: 11;
            pointer-events: none;
        }

        .hud-left,
        .hud-right {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .hud-right {
            align-items: flex-end;
        }

        .hud-item {
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
            font-weight: 600;
        }

        .hud-score {
            font-size: 22px;
            font-weight: 800;
        }

        .hud-combo {
            color: #ffdd57;
            font-size: 18px;
            font-weight: 800;
            transition: transform 0.15s;
            display: none;
        }

        .hud-combo.active {
            display: block;
            animation: comboPop 0.3s ease;
        }

        @keyframes comboPop {
            0% {
                transform: scale(1.6);
            }

            100% {
                transform: scale(1);
            }
        }

        .hud-badge {
            display: inline-block;
            padding: 2px 10px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 800;
            letter-spacing: 1px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(4px);
        }
    </style>
</head>

<body>
    <div id="wrapper">
        <canvas id="game"></canvas>
        <div id="ui-overlay"></div>
        <div id="hud">
            <div class="hud-left">
                <div class="hud-item hud-score" id="hud-score">0</div>
                <div class="hud-item" id="hud-coins">ü™ô 0</div>
                <div class="hud-combo" id="hud-combo">üî• x2</div>
            </div>
            <div class="hud-right">
                <div class="hud-item" id="hud-hi">üëë 0</div>
                <div class="hud-item hud-badge" id="hud-diff">EASY</div>
                <div class="hud-item" id="hud-powerup" style="display:none">‚≠ê SHIELD</div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        //  NINJA JUMP DELUXE ‚Äî Ë∂ÖË±™ËèØÂÆåÊï¥Áâà
        // ============================================================

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // --- Responsive Canvas ---
        const BASE_W = 800, BASE_H = 360;
        function resizeCanvas() {
            const maxW = Math.min(window.innerWidth - 20, 800);
            const scale = maxW / BASE_W;
            canvas.width = BASE_W;
            canvas.height = BASE_H;
            canvas.style.width = maxW + 'px';
            canvas.style.height = (BASE_H * scale) + 'px';
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // --- Audio Engine (Web Audio API, no external files) ---
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        function ensureAudio() { if (!audioCtx) audioCtx = new AudioCtx(); }

        function playTone(freq, dur, type = 'square', vol = 0.12) {
            ensureAudio();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + dur);
        }
        const SFX = {
            jump: () => { playTone(440, 0.12, 'square', 0.08); playTone(660, 0.1, 'square', 0.06); },
            dbljump: () => { playTone(660, 0.1, 'square', 0.08); playTone(880, 0.12, 'square', 0.07); },
            coin: () => { playTone(988, 0.08, 'sine', 0.10); setTimeout(() => playTone(1319, 0.12, 'sine', 0.10), 60); },
            candy: () => { playTone(1200, 0.08, 'sine', 0.12); setTimeout(() => playTone(1500, 0.1, 'sine', 0.10), 50); setTimeout(() => playTone(1800, 0.12, 'sine', 0.08), 100); },
            powerup: () => { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playTone(f, 0.15, 'sine', 0.10), i * 80)); },
            hit: () => { playTone(120, 0.3, 'sawtooth', 0.15); playTone(80, 0.4, 'sawtooth', 0.10); },
            milestone: () => { [784, 988, 1175, 1568].forEach((f, i) => setTimeout(() => playTone(f, 0.2, 'sine', 0.1), i * 100)); },
        };

        // --- Game State ---
        const GROUND_Y = BASE_H - 60;
        const GRAVITY = 0.65;
        const JUMP_POWER = -13;

        let state = 'start'; // start | select | play | over
        let selectedChar = 0; // 0=ninja, 1=kunoichi, 2=dog
        let selectHover = -1; // which card is hovered
        let score = 0, coins = 0, combo = 0, comboTimer = 0;
        let hiScore = parseInt(localStorage.getItem('ninjaHi') || '0');
        let distance = 0;
        let speedMultiplier = 1;
        let baseSpeed = 4.5;
        let shakeX = 0, shakeY = 0, shakeDur = 0;
        let dayPhase = 0; // 0-1, controls sky gradient

        // --- Player ---
        const player = {
            x: 80, y: GROUND_Y, w: 34, h: 44,
            dy: 0, jumps: 0, maxJumps: 2,
            ducking: false, duckH: 26,
            running: true,
            shieldTimer: 0, magnetTimer: 0, doubleTimer: 0,
            frame: 0, frameTimer: 0,
        };

        // --- Entities ---
        let obstacles = [];
        let coinItems = [];
        let candyItems = [];
        let powerups = [];
        let particles = [];
        let bgLayers = [];
        let stars = [];
        let floatingTexts = [];

        // --- Background Setup ---
        function initStars() {
            stars = [];
            for (let i = 0; i < 60; i++) {
                stars.push({ x: Math.random() * BASE_W, y: Math.random() * (GROUND_Y - 40), s: Math.random() * 2 + 0.5, b: Math.random() });
            }
        }

        function initBgLayers() {
            bgLayers = [
                { type: 'mountains', speed: 0.15, y: GROUND_Y - 80, color1: '#2d1b69', color2: '#1a0f3d', peaks: generatePeaks(6, 60, 120) },
                { type: 'mountains', speed: 0.3, y: GROUND_Y - 50, color1: '#3b2680', color2: '#241660', peaks: generatePeaks(8, 35, 75) },
                { type: 'city', speed: 0.5, y: GROUND_Y - 30, buildings: generateBuildings(14) },
                { type: 'clouds', speed: 0.2, clouds: generateClouds(5) },
            ];
        }

        function generatePeaks(n, minH, maxH) {
            const peaks = [];
            for (let i = 0; i <= n; i++) {
                peaks.push({ x: (i / n) * (BASE_W + 200) - 100, h: minH + Math.random() * (maxH - minH) });
            }
            return peaks;
        }

        function generateBuildings(n) {
            const b = [];
            let x = -50;
            for (let i = 0; i < n; i++) {
                const w = 30 + Math.random() * 40;
                const h = 25 + Math.random() * 55;
                const windows = [];
                for (let wy = 8; wy < h - 8; wy += 12) {
                    for (let wx = 6; wx < w - 6; wx += 10) {
                        windows.push({ rx: wx, ry: wy, lit: Math.random() > 0.4 });
                    }
                }
                b.push({ x, w, h, windows });
                x += w + 8 + Math.random() * 15;
            }
            return b;
        }

        function generateClouds(n) {
            const c = [];
            for (let i = 0; i < n; i++) {
                c.push({ x: Math.random() * BASE_W, y: 30 + Math.random() * 80, w: 60 + Math.random() * 80, h: 20 + Math.random() * 15 });
            }
            return c;
        }

        // --- Obstacle / Item Spawning ---
        let spawnTimer = 0;
        let coinSpawnTimer = 0;
        let candySpawnTimer = 0;
        let powerupSpawnTimer = 0;

        function getSpeed() { return baseSpeed * speedMultiplier; }

        function spawnObstacle() {
            const types = ['cactus', 'cactus', 'cactus', 'rock', 'bird'];
            if (score > 10) types.push('bird', 'bird');
            if (score > 25) types.push('doublecactus');
            const t = types[Math.floor(Math.random() * types.length)];
            let o;
            switch (t) {
                case 'cactus':
                    o = { x: BASE_W + 20, y: GROUND_Y, w: 18, h: 36 + Math.random() * 14, type: 'cactus' }; break;
                case 'doublecactus':
                    o = { x: BASE_W + 20, y: GROUND_Y, w: 36, h: 40, type: 'doublecactus' }; break;
                case 'rock':
                    o = { x: BASE_W + 20, y: GROUND_Y, w: 28, h: 20, type: 'rock' }; break;
                case 'bird':
                    o = { x: BASE_W + 20, y: GROUND_Y - 55 - Math.random() * 30, w: 30, h: 22, type: 'bird', frame: 0 }; break;
            }
            obstacles.push(o);
        }

        function spawnCoin() {
            const pattern = Math.random();
            if (pattern < 0.5) {
                // Arc of coins
                for (let i = 0; i < 4; i++) {
                    coinItems.push({ x: BASE_W + 40 + i * 35, y: GROUND_Y - 30 - Math.sin(i / 3 * Math.PI) * 50, w: 16, h: 16, frame: 0 });
                }
            } else {
                // Line of coins
                const y = GROUND_Y - 20 - Math.random() * 60;
                for (let i = 0; i < 3; i++) {
                    coinItems.push({ x: BASE_W + 40 + i * 30, y, w: 16, h: 16, frame: 0 });
                }
            }
        }

        function spawnPowerup() {
            const types = ['shield', 'magnet', 'double'];
            const t = types[Math.floor(Math.random() * types.length)];
            powerups.push({ x: BASE_W + 20, y: GROUND_Y - 50 - Math.random() * 40, w: 22, h: 22, type: t, frame: 0 });
        }

        // --- Candy Spawning ---
        const CANDY_TYPES = [
            { name: 'lollipop', emoji: 'üç≠', color1: '#ff69b4', color2: '#ff1493', points: 3 },
            { name: 'wrapped', emoji: 'üç¨', color1: '#00e5ff', color2: '#2979ff', points: 3 },
            { name: 'chocolate', emoji: 'üç´', color1: '#d2691e', color2: '#8b4513', points: 3 },
        ];

        function spawnCandy() {
            const ctype = CANDY_TYPES[Math.floor(Math.random() * CANDY_TYPES.length)];
            const baseY = 60 + Math.random() * (GROUND_Y - 140);
            candyItems.push({
                x: BASE_W + 30,
                y: baseY,
                baseY: baseY,
                w: 24, h: 24,
                type: ctype,
                frame: Math.random() * Math.PI * 2,
                speed: 1.5 + Math.random() * 1.5, // independent flying speed
                waveAmp: 15 + Math.random() * 20,
                waveFreq: 0.03 + Math.random() * 0.02,
            });
        }

        // --- Particles ---
        function emitDust(x, y) {
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x, y: y + Math.random() * 5,
                    dx: -Math.random() * 2 - 0.5, dy: -Math.random() * 1.5,
                    life: 20 + Math.random() * 15, maxLife: 35,
                    r: 2 + Math.random() * 3, color: 'rgba(180,160,140,', type: 'dust'
                });
            }
        }

        function emitExplosion(x, y) {
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 4;
                particles.push({
                    x, y,
                    dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed,
                    life: 30 + Math.random() * 20, maxLife: 50,
                    r: 2 + Math.random() * 4,
                    color: ['rgba(255,100,50,', 'rgba(255,200,50,', 'rgba(255,60,60,'][Math.floor(Math.random() * 3)],
                    type: 'explosion'
                });
            }
        }

        function emitCoinParticles(x, y) {
            for (let i = 0; i < 8; i++) {
                const angle = Math.random() * Math.PI * 2;
                particles.push({
                    x, y, dx: Math.cos(angle) * 2, dy: Math.sin(angle) * 2,
                    life: 20, maxLife: 20, r: 2, color: 'rgba(255,215,0,', type: 'sparkle'
                });
            }
        }

        function emitCandyParticles(x, y, color1) {
            for (let i = 0; i < 12; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1.5 + Math.random() * 3;
                const colors = [
                    'rgba(255,105,180,', 'rgba(0,229,255,', 'rgba(255,215,0,',
                    'rgba(255,100,100,', 'rgba(150,255,150,'
                ];
                particles.push({
                    x, y,
                    dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed,
                    life: 25 + Math.random() * 15, maxLife: 40,
                    r: 2 + Math.random() * 3,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    type: 'sparkle'
                });
            }
        }

        function addFloatingText(x, y, text, color = '#ffdd57') {
            floatingTexts.push({ x, y, text, color, life: 40, dy: -1.5 });
        }

        // --- Collision ---
        function rectsOverlap(a, b) {
            const ah = a.ducking ? a.duckH : a.h;
            const ay = a.ducking ? a.y - a.duckH + a.h : a.y;
            return a.x < b.x + b.w && a.x + a.w > b.x && ay < b.y + b.h && ay + ah > b.y;
        }

        function playerRect() {
            const h = player.ducking ? player.duckH : player.h;
            return { x: player.x + 4, y: player.y - h + 4, w: player.w - 8, h: h - 8 };
        }

        function obstacleRect(o) {
            if (o.type === 'bird') return { x: o.x + 2, y: o.y + 2, w: o.w - 4, h: o.h - 4 };
            return { x: o.x + 2, y: o.y - o.h + 2, w: o.w - 4, h: o.h - 4 };
        }

        // --- Difficulty ---
        function getDifficulty() {
            if (score < 8) return { label: 'EASY', color: '#4ade80', spawnMin: 80, spawnMax: 140 };
            if (score < 20) return { label: 'NORMAL', color: '#fbbf24', spawnMin: 60, spawnMax: 110 };
            if (score < 40) return { label: 'HARD', color: '#f97316', spawnMin: 45, spawnMax: 85 };
            if (score < 70) return { label: 'INSANE', color: '#ef4444', spawnMin: 35, spawnMax: 65 };
            return { label: 'HELL üî•', color: '#dc2626', spawnMin: 28, spawnMax: 55 };
        }

        // --- Screen Shake ---
        function triggerShake(dur = 12) { shakeDur = dur; }
        function updateShake() {
            if (shakeDur > 0) {
                shakeDur--;
                shakeX = (Math.random() - 0.5) * shakeDur * 0.8;
                shakeY = (Math.random() - 0.5) * shakeDur * 0.5;
            } else { shakeX = 0; shakeY = 0; }
        }

        // ============================================================
        //  DRAWING FUNCTIONS
        // ============================================================

        function drawSky() {
            dayPhase = (Math.sin(distance * 0.0002) + 1) / 2; // 0=night, 1=day
            const night = ctx.createLinearGradient(0, 0, 0, BASE_H);
            night.addColorStop(0, '#0a0a2e');
            night.addColorStop(0.5, '#1a1a4e');
            night.addColorStop(1, '#2a1a3e');

            const day = ctx.createLinearGradient(0, 0, 0, BASE_H);
            day.addColorStop(0, '#1a1040');
            day.addColorStop(0.4, '#2d1b69');
            day.addColorStop(1, '#4a2080');

            // Blend
            ctx.fillStyle = night;
            ctx.fillRect(0, 0, BASE_W, BASE_H);
            ctx.globalAlpha = dayPhase * 0.6;
            ctx.fillStyle = day;
            ctx.fillRect(0, 0, BASE_W, BASE_H);
            ctx.globalAlpha = 1;
        }

        function drawStars() {
            const alpha = Math.max(0, 1 - dayPhase * 1.5);
            if (alpha <= 0) return;
            stars.forEach(s => {
                s.b += 0.02;
                const a = (Math.sin(s.b) * 0.4 + 0.6) * alpha;
                ctx.fillStyle = `rgba(255,255,255,${a})`;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.s, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawMountains(layer) {
            const offset = (distance * layer.speed) % (BASE_W + 200);
            ctx.fillStyle = layer.color1;
            ctx.beginPath();
            ctx.moveTo(-100 - offset, BASE_H);
            layer.peaks.forEach(p => {
                ctx.lineTo(p.x - offset, layer.y - p.h);
            });
            // repeat
            layer.peaks.forEach(p => {
                ctx.lineTo(p.x - offset + BASE_W + 200, layer.y - p.h);
            });
            ctx.lineTo(BASE_W + 200, BASE_H);
            ctx.closePath();
            ctx.fill();
        }

        function drawCity(layer) {
            const offset = (distance * layer.speed) % 800;
            ctx.save();
            layer.buildings.forEach(b => {
                const bx = b.x - offset;
                const drawX = ((bx % 800) + 800) % 800 - 50;
                const by = GROUND_Y - b.h;
                // Building body
                ctx.fillStyle = '#1a1035';
                ctx.fillRect(drawX, by, b.w, b.h);
                // Windows
                b.windows.forEach(win => {
                    ctx.fillStyle = win.lit ? 'rgba(255,220,100,0.7)' : 'rgba(50,50,80,0.5)';
                    ctx.fillRect(drawX + win.rx, by + win.ry, 5, 7);
                });
            });
            ctx.restore();
        }

        function drawClouds(layer) {
            const offset = (distance * layer.speed) % (BASE_W + 200);
            ctx.save();
            layer.clouds.forEach(c => {
                const cx = ((c.x - offset) % (BASE_W + 200) + BASE_W + 200) % (BASE_W + 200) - 100;
                ctx.fillStyle = `rgba(255,255,255,${0.06 + dayPhase * 0.04})`;
                ctx.beginPath();
                ctx.ellipse(cx, c.y, c.w / 2, c.h / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cx - c.w * 0.25, c.y + 5, c.w * 0.3, c.h * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cx + c.w * 0.3, c.y + 3, c.w * 0.25, c.h * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();
        }

        function drawGround() {
            // Ground line
            const grd = ctx.createLinearGradient(0, GROUND_Y, 0, BASE_H);
            grd.addColorStop(0, '#2a1a50');
            grd.addColorStop(1, '#150d30');
            ctx.fillStyle = grd;
            ctx.fillRect(0, GROUND_Y, BASE_W, BASE_H - GROUND_Y);

            // Running lines
            ctx.strokeStyle = 'rgba(255,255,255,0.08)';
            ctx.lineWidth = 1;
            const lineOffset = (distance * 3) % 40;
            for (let x = -40 + lineOffset; x < BASE_W + 40; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, GROUND_Y + 1);
                ctx.lineTo(x - 15, GROUND_Y + BASE_H - GROUND_Y);
                ctx.stroke();
            }

            // Top edge glow
            ctx.strokeStyle = 'rgba(150,100,255,0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, GROUND_Y);
            ctx.lineTo(BASE_W, GROUND_Y);
            ctx.stroke();
        }

        function drawNinja() {
            const p = player;
            const h = p.ducking ? p.duckH : p.h;
            const bx = p.x;
            const by = p.y - h;

            ctx.save();

            // Shield glow
            if (p.shieldTimer > 0) {
                const a = 0.2 + Math.sin(Date.now() * 0.01) * 0.1;
                ctx.shadowColor = '#4af';
                ctx.shadowBlur = 20;
                ctx.strokeStyle = `rgba(80,180,255,${a})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(bx + p.w / 2, by + h / 2, Math.max(p.w, h) / 2 + 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Draw character based on selection
            if (selectedChar === 0) drawMaleNinja(bx, by, h, p);
            else if (selectedChar === 1) drawFemaleNinja(bx, by, h, p);
            else drawNinjaDog(bx, by, h, p);

            // Double score aura
            if (p.doubleTimer > 0) {
                ctx.strokeStyle = `rgba(255,215,0,${0.3 + Math.sin(Date.now() * 0.008) * 0.2})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(bx + p.w / 2, by + h / 2, Math.max(p.w, h) / 2 + 14, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.restore();
        }

        // --- Character 1: Handsome Male Ninja ---
        function drawMaleNinja(bx, by, h, p) {
            const bodyGrad = ctx.createLinearGradient(bx, by, bx, by + h);
            bodyGrad.addColorStop(0, '#1a1a2e');
            bodyGrad.addColorStop(1, '#16213e');
            ctx.fillStyle = bodyGrad;

            if (p.ducking) {
                ctx.fillRect(bx - 5, by + 4, p.w + 10, h - 4);
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(bx + 14, by + 8, 5, 3);
                ctx.fillRect(bx + 22, by + 8, 5, 3);
            } else {
                ctx.fillRect(bx + 2, by + 10, p.w - 4, h - 10);
                ctx.fillStyle = '#1a1a2e';
                ctx.beginPath();
                ctx.arc(bx + p.w / 2, by + 10, 11, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(bx + 3, by + 6, p.w - 6, 4);
                const tailWave = Math.sin(Date.now() * 0.01 + distance * 0.05) * 3;
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bx + 3, by + 8);
                ctx.quadraticCurveTo(bx - 8, by + 5 + tailWave, bx - 14, by + 10 + tailWave);
                ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.fillRect(bx + 12, by + 7, 4, 3);
                ctx.fillRect(bx + 20, by + 7, 4, 3);
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(bx + 14, by + 8, 2, 2);
                ctx.fillRect(bx + 22, by + 8, 2, 2);
                if (p.y >= GROUND_Y - 1) {
                    const legPhase = Math.sin(distance * 0.3) * 6;
                    ctx.strokeStyle = '#1a1a2e';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(bx + 10, by + h);
                    ctx.lineTo(bx + 10 + legPhase, by + h + 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(bx + p.w - 10, by + h);
                    ctx.lineTo(bx + p.w - 10 - legPhase, by + h + 2);
                    ctx.stroke();
                }
                ctx.strokeStyle = '#16213e';
                ctx.lineWidth = 3;
                const armSwing = Math.sin(distance * 0.3) * 8;
                ctx.beginPath();
                ctx.moveTo(bx + 2, by + 18);
                ctx.lineTo(bx - 4, by + 25 + armSwing);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(bx + p.w - 2, by + 18);
                ctx.lineTo(bx + p.w + 4, by + 25 - armSwing);
                ctx.stroke();
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(bx + p.w - 4, by + 5);
                ctx.lineTo(bx + p.w + 6, by - 10);
                ctx.stroke();
                ctx.fillStyle = '#c8a000';
                ctx.fillRect(bx + p.w - 5, by + 3, 4, 5);
            }
        }

        // --- Character 2: Beautiful Female Ninja (Kunoichi) ---
        function drawFemaleNinja(bx, by, h, p) {
            const bodyGrad = ctx.createLinearGradient(bx, by, bx, by + h);
            bodyGrad.addColorStop(0, '#2d1050');
            bodyGrad.addColorStop(1, '#4a1a6e');
            ctx.fillStyle = bodyGrad;

            if (p.ducking) {
                ctx.fillRect(bx - 5, by + 4, p.w + 10, h - 4);
                // Eyes
                ctx.fillStyle = '#e040fb';
                ctx.fillRect(bx + 13, by + 8, 5, 2);
                ctx.fillRect(bx + 22, by + 8, 5, 2);
            } else {
                // Body (slimmer)
                ctx.fillRect(bx + 4, by + 10, p.w - 8, h - 10);
                // Skirt flare
                ctx.beginPath();
                ctx.moveTo(bx + 2, by + h - 10);
                ctx.lineTo(bx + p.w + 2, by + h - 10);
                ctx.lineTo(bx + p.w + 4, by + h);
                ctx.lineTo(bx - 2, by + h);
                ctx.closePath();
                ctx.fill();
                // Head
                ctx.fillStyle = '#2d1050';
                ctx.beginPath();
                ctx.arc(bx + p.w / 2, by + 10, 11, 0, Math.PI * 2);
                ctx.fill();
                // Headband (purple/pink)
                ctx.fillStyle = '#e040fb';
                ctx.fillRect(bx + 3, by + 6, p.w - 6, 4);
                // Ponytail
                const tailWave = Math.sin(Date.now() * 0.012 + distance * 0.06) * 4;
                ctx.strokeStyle = '#2d1050';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(bx + p.w / 2, by + 4);
                ctx.quadraticCurveTo(bx + p.w + 8, by - 5 + tailWave, bx + p.w + 4, by + 18 + tailWave);
                ctx.stroke();
                // Hair ribbon
                ctx.fillStyle = '#ff69b4';
                ctx.beginPath();
                ctx.arc(bx + p.w / 2 + 2, by + 3, 3, 0, Math.PI * 2);
                ctx.fill();
                // Eyes (larger, prettier)
                ctx.fillStyle = '#fff';
                ctx.fillRect(bx + 11, by + 6, 5, 4);
                ctx.fillRect(bx + 20, by + 6, 5, 4);
                ctx.fillStyle = '#e040fb';
                ctx.fillRect(bx + 13, by + 7, 3, 3);
                ctx.fillRect(bx + 22, by + 7, 3, 3);
                // Eyelashes
                ctx.strokeStyle = '#2d1050';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(bx + 11, by + 6); ctx.lineTo(bx + 10, by + 4);
                ctx.moveTo(bx + 25, by + 6); ctx.lineTo(bx + 26, by + 4);
                ctx.stroke();
                // Legs
                if (p.y >= GROUND_Y - 1) {
                    const legPhase = Math.sin(distance * 0.3) * 5;
                    ctx.strokeStyle = '#2d1050';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(bx + 12, by + h);
                    ctx.lineTo(bx + 12 + legPhase, by + h + 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(bx + p.w - 12, by + h);
                    ctx.lineTo(bx + p.w - 12 - legPhase, by + h + 2);
                    ctx.stroke();
                }
                // Arms
                ctx.strokeStyle = '#4a1a6e';
                ctx.lineWidth = 2.5;
                const armSwing = Math.sin(distance * 0.3) * 7;
                ctx.beginPath();
                ctx.moveTo(bx + 4, by + 18);
                ctx.lineTo(bx - 3, by + 24 + armSwing);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(bx + p.w - 4, by + 18);
                ctx.lineTo(bx + p.w + 3, by + 24 - armSwing);
                ctx.stroke();
                // Kunai in hand
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(bx + p.w + 3, by + 24 - armSwing);
                ctx.lineTo(bx + p.w + 9, by + 20 - armSwing);
                ctx.stroke();
            }
        }

        // --- Character 3: Cute Ninja Dog ---
        function drawNinjaDog(bx, by, h, p) {
            const bodyGrad = ctx.createLinearGradient(bx, by, bx, by + h);
            bodyGrad.addColorStop(0, '#8B6914');
            bodyGrad.addColorStop(1, '#a07828');
            ctx.fillStyle = bodyGrad;

            if (p.ducking) {
                // Flat dog
                ctx.beginPath();
                ctx.ellipse(bx + p.w / 2, by + h / 2 + 4, p.w / 2 + 8, h / 2 - 2, 0, 0, Math.PI * 2);
                ctx.fill();
                // Eyes (squinting)
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(bx + 10, by + h / 2 + 2); ctx.lineTo(bx + 18, by + h / 2 + 2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(bx + 22, by + h / 2 + 2); ctx.lineTo(bx + 30, by + h / 2 + 2); ctx.stroke();
            } else {
                // Body (rounder, dog-like)
                ctx.beginPath();
                ctx.ellipse(bx + p.w / 2, by + h - 14, p.w / 2 + 2, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                // Belly
                ctx.fillStyle = '#d4a843';
                ctx.beginPath();
                ctx.ellipse(bx + p.w / 2, by + h - 10, p.w / 2 - 4, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                // Head
                ctx.fillStyle = '#8B6914';
                ctx.beginPath();
                ctx.arc(bx + p.w / 2, by + 12, 13, 0, Math.PI * 2);
                ctx.fill();
                // Snout
                ctx.fillStyle = '#d4a843';
                ctx.beginPath();
                ctx.ellipse(bx + p.w / 2 + 4, by + 16, 7, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                // Nose
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.arc(bx + p.w / 2 + 8, by + 14, 3, 0, Math.PI * 2);
                ctx.fill();
                // Tongue
                const tongueWag = Math.sin(Date.now() * 0.008) * 2;
                ctx.fillStyle = '#ff6b8a';
                ctx.beginPath();
                ctx.ellipse(bx + p.w / 2 + 6 + tongueWag, by + 21, 3, 4, 0.2, 0, Math.PI * 2);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(bx + 12, by + 10, 4, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(bx + 24, by + 10, 4, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#333';
                ctx.beginPath(); ctx.arc(bx + 13, by + 10, 2.5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(bx + 25, by + 10, 2.5, 0, Math.PI * 2); ctx.fill();
                // Eye sparkle
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(bx + 12, by + 9, 1, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(bx + 24, by + 9, 1, 0, Math.PI * 2); ctx.fill();
                // Floppy ears
                const earWiggle = Math.sin(Date.now() * 0.006 + distance * 0.04) * 3;
                ctx.fillStyle = '#6B4F10';
                // Left ear
                ctx.beginPath();
                ctx.ellipse(bx + 3, by + 8 + earWiggle, 5, 10, -0.4, 0, Math.PI * 2);
                ctx.fill();
                // Right ear
                ctx.beginPath();
                ctx.ellipse(bx + p.w - 1, by + 8 - earWiggle, 5, 10, 0.4, 0, Math.PI * 2);
                ctx.fill();
                // Ninja headband
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(bx + 2, by + 5, p.w, 4);
                const tbWave = Math.sin(Date.now() * 0.01 + distance * 0.05) * 3;
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bx + 2, by + 7);
                ctx.quadraticCurveTo(bx - 6, by + 4 + tbWave, bx - 12, by + 9 + tbWave);
                ctx.stroke();
                // Legs (4 legs!)
                if (p.y >= GROUND_Y - 1) {
                    const legPhase = Math.sin(distance * 0.4) * 5;
                    ctx.strokeStyle = '#8B6914';
                    ctx.lineWidth = 4;
                    // Front legs
                    ctx.beginPath(); ctx.moveTo(bx + 8, by + h); ctx.lineTo(bx + 8 + legPhase, by + h + 3); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(bx + p.w - 6, by + h); ctx.lineTo(bx + p.w - 6 - legPhase, by + h + 3); ctx.stroke();
                    // Back legs
                    ctx.beginPath(); ctx.moveTo(bx + 14, by + h); ctx.lineTo(bx + 14 - legPhase, by + h + 3); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(bx + p.w - 12, by + h); ctx.lineTo(bx + p.w - 12 + legPhase, by + h + 3); ctx.stroke();
                }
                // Tail (wagging)
                const tailWag = Math.sin(Date.now() * 0.015) * 15;
                ctx.strokeStyle = '#8B6914';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(bx - 2, by + h - 18);
                ctx.quadraticCurveTo(bx - 14, by + h - 30 + tailWag, bx - 10, by + h - 38 + tailWag);
                ctx.stroke();
            }
        }

        function drawObstacle(o) {
            ctx.save();
            if (o.type === 'cactus') {
                // Cactus
                const cx = o.x, cy = o.y - o.h;
                ctx.fillStyle = '#2d8a4e';
                ctx.fillRect(cx + 5, cy, 8, o.h);
                // Arms
                ctx.fillRect(cx, cy + 10, 6, 4);
                ctx.fillRect(cx, cy + 10, 4, 14);
                ctx.fillRect(cx + 13, cy + 16, 5, 4);
                ctx.fillRect(cx + 14, cy + 16, 4, 12);
                // Spines glow
                ctx.fillStyle = 'rgba(100,255,100,0.3)';
                ctx.fillRect(cx + 4, cy - 2, 10, 2);
            } else if (o.type === 'doublecactus') {
                ctx.fillStyle = '#2d8a4e';
                ctx.fillRect(o.x + 4, o.y - o.h, 8, o.h);
                ctx.fillRect(o.x + 22, o.y - o.h + 6, 8, o.h - 6);
                ctx.fillRect(o.x, o.y - o.h + 10, 5, 4);
                ctx.fillRect(o.x + 30, o.y - o.h + 18, 5, 4);
                ctx.fillStyle = 'rgba(100,255,100,0.3)';
                ctx.fillRect(o.x + 3, o.y - o.h - 2, 28, 2);
            } else if (o.type === 'rock') {
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(o.x, o.y);
                ctx.lineTo(o.x + 5, o.y - o.h);
                ctx.lineTo(o.x + o.w - 5, o.y - o.h - 3);
                ctx.lineTo(o.x + o.w, o.y);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.moveTo(o.x + 8, o.y - o.h + 2);
                ctx.lineTo(o.x + o.w / 2, o.y - o.h - 6);
                ctx.lineTo(o.x + o.w - 3, o.y - o.h + 3);
                ctx.closePath();
                ctx.fill();
            } else if (o.type === 'bird') {
                o.frame = (o.frame || 0) + 0.08;
                const wingY = Math.sin(o.frame * 4) * 8;
                ctx.fillStyle = '#8b0000';
                // Body
                ctx.beginPath();
                ctx.ellipse(o.x + o.w / 2, o.y + o.h / 2, o.w / 2, o.h / 3, 0, 0, Math.PI * 2);
                ctx.fill();
                // Wings
                ctx.beginPath();
                ctx.moveTo(o.x + 5, o.y + o.h / 2);
                ctx.lineTo(o.x + o.w / 2, o.y - 2 + wingY);
                ctx.lineTo(o.x + o.w - 5, o.y + o.h / 2);
                ctx.closePath();
                ctx.fill();
                // Eye
                ctx.fillStyle = '#ff0';
                ctx.beginPath();
                ctx.arc(o.x + o.w - 6, o.y + o.h / 2 - 2, 2, 0, Math.PI * 2);
                ctx.fill();
                // Beak
                ctx.fillStyle = '#ff8c00';
                ctx.beginPath();
                ctx.moveTo(o.x + o.w, o.y + o.h / 2 - 1);
                ctx.lineTo(o.x + o.w + 6, o.y + o.h / 2 + 1);
                ctx.lineTo(o.x + o.w, o.y + o.h / 2 + 3);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
        }

        function drawCoin(c) {
            c.frame += 0.06;
            const scaleX = Math.abs(Math.cos(c.frame));
            ctx.save();
            ctx.translate(c.x + c.w / 2, c.y + c.h / 2);
            ctx.scale(scaleX, 1);
            // Outer
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            // Inner
            ctx.fillStyle = '#ffec44';
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fill();
            // $ symbol
            ctx.fillStyle = '#b8860b';
            ctx.font = 'bold 9px Outfit';
            ctx.textAlign = 'center';
            ctx.fillText('$', 0, 3);
            ctx.restore();

            // Magnet pull effect
            if (player.magnetTimer > 0) {
                ctx.strokeStyle = 'rgba(255,100,255,0.3)';
                ctx.setLineDash([2, 4]);
                ctx.beginPath();
                ctx.moveTo(c.x + c.w / 2, c.y + c.h / 2);
                ctx.lineTo(player.x + player.w / 2, player.y - player.h / 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function drawCandy(c) {
            c.frame += 0.05;
            const floatY = Math.sin(c.frame * 3) * c.waveAmp * 0.3;
            const cx = c.x + c.w / 2;
            const cy = c.y + c.h / 2 + floatY;

            ctx.save();
            ctx.translate(cx, cy);

            // Outer glow
            const glow = ctx.createRadialGradient(0, 0, 6, 0, 0, 20);
            glow.addColorStop(0, c.type.color1 + '55');
            glow.addColorStop(1, c.type.color1 + '00');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();

            // Rotation
            const rot = Math.sin(c.frame * 2) * 0.3;
            ctx.rotate(rot);

            if (c.type.name === 'lollipop') {
                // Stick
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 5);
                ctx.lineTo(0, 14);
                ctx.stroke();
                // Swirl head
                const grad = ctx.createRadialGradient(-2, -2, 2, 0, 0, 9);
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.4, c.type.color1);
                grad.addColorStop(1, c.type.color2);
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(0, -1, 9, 0, Math.PI * 2);
                ctx.fill();
                // Swirl lines
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(0, -1, 5, c.frame * 2, c.frame * 2 + Math.PI);
                ctx.stroke();
            } else if (c.type.name === 'wrapped') {
                // Wrapper body
                const grad = ctx.createLinearGradient(-8, -6, 8, 6);
                grad.addColorStop(0, c.type.color1);
                grad.addColorStop(0.5, '#fff');
                grad.addColorStop(1, c.type.color2);
                ctx.fillStyle = grad;
                roundRectPath(ctx, -8, -6, 16, 12, 3);
                ctx.fill();
                // Wrapper twist ends
                ctx.strokeStyle = c.type.color1;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-8, 0); ctx.lineTo(-13, -4);
                ctx.moveTo(-8, 0); ctx.lineTo(-13, 4);
                ctx.moveTo(8, 0); ctx.lineTo(13, -4);
                ctx.moveTo(8, 0); ctx.lineTo(13, 4);
                ctx.stroke();
            } else {
                // Chocolate bar
                const grad = ctx.createLinearGradient(-9, -6, 9, 6);
                grad.addColorStop(0, c.type.color1);
                grad.addColorStop(1, c.type.color2);
                ctx.fillStyle = grad;
                roundRectPath(ctx, -9, -6, 18, 12, 2);
                ctx.fill();
                // Segments
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.moveTo(-3, -6); ctx.lineTo(-3, 6);
                ctx.moveTo(3, -6); ctx.lineTo(3, 6);
                ctx.stroke();
                // Shine
                ctx.fillStyle = 'rgba(255,255,255,0.25)';
                roundRectPath(ctx, -8, -5, 6, 3, 1);
                ctx.fill();
            }

            // Sparkle trail
            const sparkleA = (Math.sin(c.frame * 6) + 1) / 2 * 0.8;
            ctx.fillStyle = `rgba(255,255,255,${sparkleA})`;
            ctx.beginPath();
            ctx.arc(8 + Math.sin(c.frame * 4) * 3, -6 + Math.cos(c.frame * 5) * 3, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-6 + Math.cos(c.frame * 3) * 4, 5 + Math.sin(c.frame * 4) * 2, 1, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function roundRectPath(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function drawPowerup(p) {
            p.frame += 0.04;
            const float = Math.sin(p.frame * 3) * 4;
            ctx.save();
            ctx.translate(p.x + p.w / 2, p.y + p.h / 2 + float);

            // Glow
            const g = ctx.createRadialGradient(0, 0, 4, 0, 0, 18);
            let glowColor, icon;
            if (p.type === 'shield') { glowColor = 'rgba(80,180,255,'; icon = 'üõ°Ô∏è'; }
            else if (p.type === 'magnet') { glowColor = 'rgba(255,80,255,'; icon = 'üß≤'; }
            else { glowColor = 'rgba(255,215,0,'; icon = 'x2'; }

            g.addColorStop(0, glowColor + '0.4)');
            g.addColorStop(1, glowColor + '0)');
            ctx.fillStyle = g;
            ctx.fillRect(-18, -18, 36, 36);

            // Box
            ctx.fillStyle = glowColor + '0.8)';
            ctx.beginPath();
            ctx.arc(0, 0, 11, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Icon
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 11px Outfit';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(icon, 0, 1);

            ctx.restore();
        }

        function drawParticles() {
            particles.forEach(p => {
                const t = p.life / p.maxLife;
                ctx.fillStyle = p.color + t + ')';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r * t, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawFloatingTexts() {
            floatingTexts.forEach(f => {
                const t = f.life / 40;
                ctx.fillStyle = f.color;
                ctx.globalAlpha = t;
                ctx.font = 'bold 16px Outfit';
                ctx.textAlign = 'center';
                ctx.fillText(f.text, f.x, f.y);
                ctx.globalAlpha = 1;
            });
        }

        // --- Start Screen ---
        function drawStartScreen() {
            drawSky();
            drawStars();
            bgLayers.forEach(l => {
                if (l.type === 'clouds') drawClouds(l);
                else if (l.type === 'mountains') drawMountains(l);
                else if (l.type === 'city') drawCity(l);
            });
            drawGround();

            // Overlay
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0, 0, BASE_W, BASE_H);

            // Title
            const pulse = Math.sin(Date.now() * 0.003) * 0.08 + 1;
            ctx.save();
            ctx.translate(BASE_W / 2, 90);
            ctx.scale(pulse, pulse);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 42px Outfit';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#e74c3c';
            ctx.shadowBlur = 30;
            ctx.fillText('ü•∑ NINJA JUMP', 0, 0);
            ctx.shadowBlur = 0;
            ctx.font = 'bold 18px Outfit';
            ctx.fillStyle = '#e74c3c';
            ctx.fillText('D E L U X E', 0, 28);
            ctx.restore();

            // Subtitle
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.font = '14px Outfit';
            ctx.textAlign = 'center';
            ctx.fillText('ÂøçËÄÖË∑≥Ë∫ç ‚Äî Ë∂ÖË±™ËèØÂÆåÊï¥Áâà', BASE_W / 2, 150);

            // Controls
            ctx.fillStyle = '#fff';
            ctx.font = '14px Outfit';
            ctx.fillText('üéÆ ÊìçÊéßÊñπÂºè', BASE_W / 2, 195);

            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.font = '13px Outfit';
            ctx.fillText('‚¨Ü Á©∫ÁôΩÈçµ / ÈªûÊìä = Ë∑≥Ë∫çÔºàÂèØ‰∫åÊÆµË∑≥Ôºâ', BASE_W / 2, 218);
            ctx.fillText('‚¨á ÊñπÂêëÈçµ‚Üì / ‰∏ãÊªë = Ëπ≤‰∏ãÈñÉÈÅøÈ£õÈ≥•', BASE_W / 2, 238);

            // Blink prompt
            const blink = Math.sin(Date.now() * 0.005) > 0;
            if (blink) {
                ctx.fillStyle = '#ffdd57';
                ctx.font = 'bold 16px Outfit';
                ctx.fillText('‚Äî Êåâ‰ªªÊÑèÈçµÊàñÈªûÊìäÈñãÂßã ‚Äî', BASE_W / 2, 290);
            }

            // High score
            if (hiScore > 0) {
                ctx.fillStyle = 'rgba(255,215,0,0.8)';
                ctx.font = '13px Outfit';
                ctx.fillText(`üëë ÊúÄÈ´òÁ¥ÄÈåÑ: ${hiScore}`, BASE_W / 2, 325);
            }
        }

        // --- Character Select Screen ---
        const CHAR_DATA = [
            { name: 'Â∏•ÂøçËÄÖ', sub: 'Shadow Ninja', emoji: 'ü•∑', color: '#e74c3c', bgColor: '#1a1a2e' },
            { name: 'Â•≥ÂøçËÄÖ', sub: 'Kunoichi', emoji: 'üíú', color: '#e040fb', bgColor: '#2d1050' },
            { name: 'ÂøçËÄÖÁä¨', sub: 'Ninja Dog', emoji: 'üêï', color: '#ffa726', bgColor: '#5a3e10' },
        ];

        function getCharCardRects() {
            const cardW = 160, cardH = 200, gap = 30;
            const totalW = cardW * 3 + gap * 2;
            const startX = (BASE_W - totalW) / 2;
            const startY = 75;
            return CHAR_DATA.map((_, i) => ({
                x: startX + i * (cardW + gap),
                y: startY,
                w: cardW,
                h: cardH
            }));
        }

        function drawCharPreview(cx, cy, charIdx, scale) {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.scale(scale, scale);
            const t = Date.now() * 0.003;

            if (charIdx === 0) {
                // Male ninja preview
                const bodyGrad = ctx.createLinearGradient(-10, -22, -10, 22);
                bodyGrad.addColorStop(0, '#1a1a2e'); bodyGrad.addColorStop(1, '#16213e');
                ctx.fillStyle = bodyGrad;
                ctx.fillRect(-15, -10, 30, 32);
                ctx.fillStyle = '#1a1a2e';
                ctx.beginPath(); ctx.arc(0, -12, 12, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(-13, -16, 26, 4);
                const tw = Math.sin(t * 3) * 3;
                ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(-13, -14);
                ctx.quadraticCurveTo(-22, -17 + tw, -26, -12 + tw); ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.fillRect(-6, -15, 4, 3); ctx.fillRect(4, -15, 4, 3);
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(-4, -14, 2, 2); ctx.fillRect(6, -14, 2, 2);
                ctx.strokeStyle = '#888'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(12, -8); ctx.lineTo(18, -20); ctx.stroke();
                ctx.fillStyle = '#c8a000'; ctx.fillRect(11, -10, 4, 5);
            } else if (charIdx === 1) {
                // Female ninja preview
                const bodyGrad = ctx.createLinearGradient(-10, -22, -10, 22);
                bodyGrad.addColorStop(0, '#2d1050'); bodyGrad.addColorStop(1, '#4a1a6e');
                ctx.fillStyle = bodyGrad;
                ctx.fillRect(-12, -10, 24, 28);
                ctx.beginPath();
                ctx.moveTo(-14, 14); ctx.lineTo(14, 14);
                ctx.lineTo(16, 22); ctx.lineTo(-16, 22); ctx.closePath(); ctx.fill();
                ctx.fillStyle = '#2d1050';
                ctx.beginPath(); ctx.arc(0, -12, 12, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#e040fb';
                ctx.fillRect(-13, -16, 26, 4);
                const tw2 = Math.sin(t * 3.5) * 4;
                ctx.strokeStyle = '#2d1050'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.moveTo(2, -22);
                ctx.quadraticCurveTo(18, -24 + tw2, 15, -4 + tw2); ctx.stroke();
                ctx.fillStyle = '#ff69b4';
                ctx.beginPath(); ctx.arc(4, -22, 3, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.fillRect(-7, -16, 5, 4); ctx.fillRect(3, -16, 5, 4);
                ctx.fillStyle = '#e040fb';
                ctx.fillRect(-5, -15, 3, 3); ctx.fillRect(5, -15, 3, 3);
            } else {
                // Dog preview
                ctx.fillStyle = '#8B6914';
                ctx.beginPath(); ctx.ellipse(0, 8, 18, 14, 0, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#d4a843';
                ctx.beginPath(); ctx.ellipse(0, 12, 12, 8, 0, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#8B6914';
                ctx.beginPath(); ctx.arc(0, -10, 14, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#d4a843';
                ctx.beginPath(); ctx.ellipse(5, -6, 7, 5, 0, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#222';
                ctx.beginPath(); ctx.arc(9, -8, 3, 0, Math.PI * 2); ctx.fill();
                const ew = Math.sin(t * 2.5) * 3;
                ctx.fillStyle = '#6B4F10';
                ctx.beginPath(); ctx.ellipse(-12, -8 + ew, 5, 10, -0.4, 0, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(12, -8 - ew, 5, 10, 0.4, 0, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(-6, -12, 4, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(6, -12, 4, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#333';
                ctx.beginPath(); ctx.arc(-5, -12, 2.5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(7, -12, 2.5, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(-6, -13, 1, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(6, -13, 1, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(-13, -17, 26, 4);
                const tw3 = Math.sin(t * 4) * 12;
                ctx.strokeStyle = '#8B6914'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.moveTo(-16, 2);
                ctx.quadraticCurveTo(-26, -10 + tw3, -22, -18 + tw3); ctx.stroke();
                const tongueWag = Math.sin(t * 2.5) * 2;
                ctx.fillStyle = '#ff6b8a';
                ctx.beginPath();
                ctx.ellipse(8 + tongueWag, -1, 3, 5, 0.2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawSelectScreen() {
            drawSky();
            drawStars();
            bgLayers.forEach(l => {
                if (l.type === 'clouds') drawClouds(l);
                else if (l.type === 'mountains') drawMountains(l);
                else if (l.type === 'city') drawCity(l);
            });
            drawGround();

            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0, 0, BASE_W, BASE_H);

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px Outfit';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#e74c3c';
            ctx.shadowBlur = 15;
            ctx.fillText('üé≠ ÈÅ∏Êìá‰Ω†ÁöÑËßíËâ≤', BASE_W / 2, 50);
            ctx.shadowBlur = 0;

            const cards = getCharCardRects();
            cards.forEach((card, i) => {
                const isSelected = (i === selectedChar);
                const isHover = (i === selectHover);
                const charInfo = CHAR_DATA[i];

                // Card glow
                if (isSelected) {
                    ctx.shadowColor = charInfo.color;
                    ctx.shadowBlur = 20;
                }

                // Card background
                ctx.fillStyle = isSelected ? charInfo.bgColor : 'rgba(20,10,40,0.85)';
                ctx.strokeStyle = isSelected ? charInfo.color : (isHover ? 'rgba(255,255,255,0.5)' : 'rgba(100,80,160,0.4)');
                ctx.lineWidth = isSelected ? 3 : 1.5;
                roundRect(ctx, card.x, card.y, card.w, card.h, 14);
                ctx.shadowBlur = 0;

                // Character preview
                const previewScale = isSelected ? 1.8 : 1.5;
                const bounce = isSelected ? Math.sin(Date.now() * 0.004) * 3 : 0;
                drawCharPreview(card.x + card.w / 2, card.y + 85 + bounce, i, previewScale);

                // Name
                ctx.fillStyle = isSelected ? charInfo.color : '#fff';
                ctx.font = `bold ${isSelected ? 16 : 14}px Outfit`;
                ctx.textAlign = 'center';
                ctx.fillText(charInfo.emoji + ' ' + charInfo.name, card.x + card.w / 2, card.y + card.h - 42);

                // Subtitle
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '11px Outfit';
                ctx.fillText(charInfo.sub, card.x + card.w / 2, card.y + card.h - 24);

                // Selected indicator
                if (isSelected) {
                    const blink = Math.sin(Date.now() * 0.006) > -0.3;
                    if (blink) {
                        ctx.fillStyle = charInfo.color;
                        ctx.font = 'bold 11px Outfit';
                        ctx.fillText('‚ñº Â∑≤ÈÅ∏Êìá ‚ñº', card.x + card.w / 2, card.y + card.h - 8);
                    }
                }
            });

            // Bottom prompt
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '12px Outfit';
            ctx.textAlign = 'center';
            ctx.fillText('‚óÄ ‚ñ∂ ÊñπÂêëÈçµÈÅ∏Êìá  |  ÈªûÊìäËßíËâ≤Âç°ÁâáÈÅ∏Êìá', BASE_W / 2, BASE_H - 42);

            const blink = Math.sin(Date.now() * 0.005) > 0;
            if (blink) {
                ctx.fillStyle = '#ffdd57';
                ctx.font = 'bold 15px Outfit';
                ctx.fillText('Á©∫ÁôΩÈçµ / Enter Á¢∫Ë™çÂá∫ÁôºÔºÅ', BASE_W / 2, BASE_H - 20);
            }
        }

        // --- Game Over Screen ---
        function drawGameOverScreen() {
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0, 0, BASE_W, BASE_H);

            // Panel
            const pw = 320, ph = 220;
            const px = (BASE_W - pw) / 2, py = (BASE_H - ph) / 2 - 10;
            ctx.fillStyle = 'rgba(20,10,40,0.9)';
            ctx.strokeStyle = 'rgba(150,100,255,0.5)';
            ctx.lineWidth = 2;
            roundRect(ctx, px, py, pw, ph, 16);

            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 28px Outfit';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', BASE_W / 2, py + 40);

            ctx.fillStyle = '#fff';
            ctx.font = '16px Outfit';
            ctx.fillText(`ÂàÜÊï∏: ${score}`, BASE_W / 2, py + 75);
            ctx.fillText(`ü™ô ÈáëÂπ£: ${coins}`, BASE_W / 2, py + 100);
            ctx.fillText(`üìè Ë∑ùÈõ¢: ${Math.floor(distance / 10)}m`, BASE_W / 2, py + 125);

            // High score
            const isNew = score >= hiScore && score > 0;
            ctx.fillStyle = isNew ? '#ffdd57' : 'rgba(255,215,0,0.7)';
            ctx.font = isNew ? 'bold 16px Outfit' : '14px Outfit';
            ctx.fillText(isNew ? 'üéâ Êñ∞Á¥ÄÈåÑÔºÅ' : `üëë ÊúÄÈ´ò: ${hiScore}`, BASE_W / 2, py + 155);

            // Restart prompt
            const blink = Math.sin(Date.now() * 0.005) > 0;
            if (blink) {
                ctx.fillStyle = '#ffdd57';
                ctx.font = '14px Outfit';
                ctx.fillText('Êåâ‰ªªÊÑèÈçµÊàñÈªûÊìäÈáçÊñ∞ÈñãÂßã', BASE_W / 2, py + 195);
            }
        }

        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        // ============================================================
        //  UPDATE LOOP
        // ============================================================

        function update() {
            requestAnimationFrame(update);

            if (state === 'start') {
                distance += 0.5;
                drawStartScreen();
                return;
            }

            if (state === 'select') {
                distance += 0.3;
                drawSelectScreen();
                return;
            }

            if (state === 'over') {
                drawFrame();
                drawGameOverScreen();
                return;
            }

            // --- Playing ---
            const spd = getSpeed();
            distance += spd;
            speedMultiplier = 1 + Math.floor(score / 10) * 0.08;

            // Player physics
            player.dy += GRAVITY;
            player.y += player.dy;
            if (player.y >= GROUND_Y) {
                player.y = GROUND_Y;
                player.dy = 0;
                player.jumps = 0;
                if (player.running) emitDust(player.x + 5, player.y);
            }

            // Timers
            if (player.shieldTimer > 0) player.shieldTimer--;
            if (player.magnetTimer > 0) player.magnetTimer--;
            if (player.doubleTimer > 0) player.doubleTimer--;
            if (comboTimer > 0) { comboTimer--; } else { combo = 0; }

            // Spawn obstacles
            const diff = getDifficulty();
            spawnTimer--;
            if (spawnTimer <= 0) {
                spawnObstacle();
                spawnTimer = diff.spawnMin + Math.random() * (diff.spawnMax - diff.spawnMin);
            }

            // Spawn coins
            coinSpawnTimer--;
            if (coinSpawnTimer <= 0) {
                spawnCoin();
                coinSpawnTimer = 120 + Math.random() * 100;
            }

            // Spawn candy
            candySpawnTimer--;
            if (candySpawnTimer <= 0) {
                spawnCandy();
                candySpawnTimer = 180 + Math.random() * 200;
            }

            // Spawn powerups
            powerupSpawnTimer--;
            if (powerupSpawnTimer <= 0) {
                spawnPowerup();
                powerupSpawnTimer = 400 + Math.random() * 300;
            }

            // Update obstacles
            obstacles.forEach(o => { o.x -= spd; });
            const prevLen = obstacles.length;
            obstacles = obstacles.filter(o => o.x > -50);
            const passed = prevLen - obstacles.length;
            if (passed > 0) {
                score += passed;
                if (score % 10 === 0 && score > 0) SFX.milestone();
            }

            // Update coins
            coinItems.forEach(c => {
                c.x -= spd;
                // Magnet pull
                if (player.magnetTimer > 0) {
                    const dx = player.x - c.x, dy = (player.y - player.h / 2) - c.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 150) {
                        c.x += dx / dist * 5;
                        c.y += dy / dist * 5;
                    }
                }
            });

            // Update candy (flies independently with sine wave)
            candyItems.forEach(c => {
                c.x -= (spd * 0.5 + c.speed); // candy flies on its own
                c.y = c.baseY + Math.sin(c.frame * c.waveFreq * 60) * c.waveAmp;
            });

            // Update powerups
            powerups.forEach(p => { p.x -= spd; });
            powerups = powerups.filter(p => p.x > -30);

            // Collision: obstacles
            const pr = playerRect();
            for (const o of obstacles) {
                const or = obstacleRect(o);
                if (rectsOverlap(pr, or)) {
                    if (player.shieldTimer > 0) {
                        player.shieldTimer = 0;
                        emitExplosion(o.x + o.w / 2, o.y - o.h / 2);
                        obstacles = obstacles.filter(ob => ob !== o);
                        triggerShake(8);
                        addFloatingText(o.x, o.y - o.h, 'üõ°Ô∏è Ë≠∑ÁõæÊìã‰∏ãÔºÅ', '#4af');
                    } else {
                        gameOver();
                        return;
                    }
                }
            }

            // Collision: coins
            coinItems = coinItems.filter(c => {
                if (c.x < -20) return false;
                if (rectsOverlap(pr, { x: c.x, y: c.y, w: c.w, h: c.h })) {
                    const val = player.doubleTimer > 0 ? 2 : 1;
                    coins += val;
                    combo++;
                    comboTimer = 90;
                    emitCoinParticles(c.x + c.w / 2, c.y + c.h / 2);
                    addFloatingText(c.x, c.y - 10, `+${val}`, '#ffd700');
                    SFX.coin();
                    return false;
                }
                return true;
            });

            // Collision: candy
            candyItems = candyItems.filter(c => {
                if (c.x < -40) return false;
                const floatY = Math.sin(c.frame * 3) * c.waveAmp * 0.3;
                const candyRect = { x: c.x, y: c.y + floatY - 4, w: c.w, h: c.h };
                if (rectsOverlap(pr, candyRect)) {
                    const val = player.doubleTimer > 0 ? c.type.points * 2 : c.type.points;
                    score += val;
                    combo++;
                    comboTimer = 90;
                    emitCandyParticles(c.x + c.w / 2, c.y + c.h / 2 + floatY, c.type.color1);
                    addFloatingText(c.x, c.y - 10, `${c.type.emoji} +${val}`, c.type.color1);
                    SFX.candy();
                    return false;
                }
                return true;
            });

            // Collision: powerups
            powerups = powerups.filter(p => {
                if (rectsOverlap(pr, { x: p.x, y: p.y, w: p.w, h: p.h })) {
                    if (p.type === 'shield') { player.shieldTimer = 300; addFloatingText(p.x, p.y - 10, 'üõ°Ô∏è Ë≠∑Áõæ 5Áßí!', '#4af'); }
                    else if (p.type === 'magnet') { player.magnetTimer = 360; addFloatingText(p.x, p.y - 10, 'üß≤ Á£ÅÈêµ 6Áßí!', '#f0f'); }
                    else { player.doubleTimer = 300; addFloatingText(p.x, p.y - 10, 'x2 ÈõôÂÄçÂàÜÊï∏!', '#ffd700'); }
                    emitCoinParticles(p.x + p.w / 2, p.y + p.h / 2);
                    SFX.powerup();
                    return false;
                }
                return true;
            });

            // Update particles
            particles.forEach(p => {
                p.x += p.dx; p.y += p.dy;
                p.dy += 0.05;
                p.life--;
            });
            particles = particles.filter(p => p.life > 0);

            // Update floating texts
            floatingTexts.forEach(f => { f.y += f.dy; f.life--; });
            floatingTexts = floatingTexts.filter(f => f.life > 0);

            updateShake();

            // HUD updates
            updateHUD(diff);

            drawFrame();
        }

        function drawFrame() {
            ctx.save();
            ctx.translate(shakeX, shakeY);

            drawSky();
            drawStars();
            bgLayers.forEach(l => {
                if (l.type === 'clouds') drawClouds(l);
                else if (l.type === 'mountains') drawMountains(l);
                else if (l.type === 'city') drawCity(l);
            });
            drawGround();
            obstacles.forEach(drawObstacle);
            coinItems.forEach(drawCoin);
            candyItems.forEach(drawCandy);
            powerups.forEach(drawPowerup);
            drawParticles();
            drawNinja();
            drawFloatingTexts();

            ctx.restore();
        }

        function updateHUD(diff) {
            document.getElementById('hud-score').textContent = score;
            document.getElementById('hud-coins').textContent = 'ü™ô ' + coins;
            document.getElementById('hud-hi').textContent = 'üëë ' + Math.max(hiScore, score);
            document.getElementById('hud-diff').textContent = diff.label;
            document.getElementById('hud-diff').style.background = diff.color + '33';
            document.getElementById('hud-diff').style.color = diff.color;

            const comboEl = document.getElementById('hud-combo');
            if (combo >= 2) {
                comboEl.className = 'hud-combo active';
                comboEl.textContent = 'üî• x' + combo;
            } else {
                comboEl.className = 'hud-combo';
            }

            const puEl = document.getElementById('hud-powerup');
            if (player.shieldTimer > 0) { puEl.style.display = 'block'; puEl.textContent = 'üõ°Ô∏è Ë≠∑Áõæ ' + Math.ceil(player.shieldTimer / 60) + 's'; }
            else if (player.magnetTimer > 0) { puEl.style.display = 'block'; puEl.textContent = 'üß≤ Á£ÅÈêµ ' + Math.ceil(player.magnetTimer / 60) + 's'; }
            else if (player.doubleTimer > 0) { puEl.style.display = 'block'; puEl.textContent = 'x2 ÈõôÂÄç ' + Math.ceil(player.doubleTimer / 60) + 's'; }
            else { puEl.style.display = 'none'; }
        }

        // ============================================================
        //  GAME FLOW
        // ============================================================

        function startGame() {
            ensureAudio();
            state = 'play';
            score = 0; coins = 0; combo = 0; comboTimer = 0; distance = 0;
            speedMultiplier = 1;
            player.y = GROUND_Y; player.dy = 0; player.jumps = 0;
            player.ducking = false;
            player.shieldTimer = 0; player.magnetTimer = 0; player.doubleTimer = 0;
            obstacles = []; coinItems = []; candyItems = []; powerups = [];
            particles = []; floatingTexts = [];
            spawnTimer = 80; coinSpawnTimer = 60; candySpawnTimer = 100; powerupSpawnTimer = 200;
        }

        function gameOver() {
            state = 'over';
            SFX.hit();
            triggerShake(18);
            emitExplosion(player.x + player.w / 2, player.y - player.h / 2);
            if (score > hiScore) {
                hiScore = score;
                localStorage.setItem('ninjaHi', hiScore);
            }
        }

        // --- Input ---
        function doJump() {
            if (state === 'start') { state = 'select'; ensureAudio(); return; }
            if (state === 'select') { startGame(); return; }
            if (state === 'over') { state = 'select'; return; }
            if (player.jumps < player.maxJumps) {
                player.dy = JUMP_POWER + (player.jumps > 0 ? 2 : 0);
                if (player.jumps === 0) SFX.jump(); else SFX.dbljump();
                player.jumps++;
                player.ducking = false;
                emitDust(player.x + 5, player.y);
            }
        }

        function doDuck(on) {
            if (state !== 'play') return;
            player.ducking = on;
            if (on && player.y < GROUND_Y) {
                player.dy += 6;
            }
        }

        function getCanvasPos(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = BASE_W / rect.width;
            const scaleY = BASE_H / rect.height;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function handleSelectClick(cx, cy) {
            const cards = getCharCardRects();
            for (let i = 0; i < cards.length; i++) {
                const c = cards[i];
                if (cx >= c.x && cx <= c.x + c.w && cy >= c.y && cy <= c.y + c.h) {
                    selectedChar = i;
                    SFX.coin();
                    return;
                }
            }
        }

        // Keyboard
        window.addEventListener('keydown', e => {
            if (state === 'select') {
                if (e.code === 'ArrowLeft') { e.preventDefault(); selectedChar = (selectedChar + 2) % 3; SFX.coin(); return; }
                if (e.code === 'ArrowRight') { e.preventDefault(); selectedChar = (selectedChar + 1) % 3; SFX.coin(); return; }
                if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); startGame(); return; }
                return;
            }
            if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); doJump(); }
            if (e.code === 'ArrowDown') { e.preventDefault(); doDuck(true); }
            if (state === 'start' || state === 'over') {
                if (!['Space', 'ArrowUp', 'ArrowDown'].includes(e.code)) {
                    if (state === 'start') { state = 'select'; ensureAudio(); }
                    else { state = 'select'; }
                }
            }
        });
        window.addEventListener('keyup', e => {
            if (e.code === 'ArrowDown') doDuck(false);
        });

        // Mouse move for hover effect on select screen
        canvas.addEventListener('mousemove', e => {
            if (state !== 'select') { selectHover = -1; return; }
            const pos = getCanvasPos(e.clientX, e.clientY);
            const cards = getCharCardRects();
            selectHover = -1;
            for (let i = 0; i < cards.length; i++) {
                const c = cards[i];
                if (pos.x >= c.x && pos.x <= c.x + c.w && pos.y >= c.y && pos.y <= c.y + c.h) {
                    selectHover = i;
                    break;
                }
            }
        });

        // Mouse
        canvas.addEventListener('mousedown', e => {
            e.preventDefault();
            if (state === 'select') {
                const pos = getCanvasPos(e.clientX, e.clientY);
                handleSelectClick(pos.x, pos.y);
                return;
            }
            doJump();
        });

        // Double-click on select screen to confirm
        canvas.addEventListener('dblclick', e => {
            e.preventDefault();
            if (state === 'select') {
                startGame();
            }
        });

        // Touch
        let touchStartY = 0;
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            touchStartY = e.touches[0].clientY;
            if (state === 'select') {
                const pos = getCanvasPos(e.touches[0].clientX, e.touches[0].clientY);
                handleSelectClick(pos.x, pos.y);
                return;
            }
            doJump();
        }, { passive: false });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const dy = e.touches[0].clientY - touchStartY;
            if (dy > 30) doDuck(true);
        }, { passive: false });
        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            doDuck(false);
        }, { passive: false });

        // --- Init ---
        initStars();
        initBgLayers();
        update();

    </script>
</body>

</html>